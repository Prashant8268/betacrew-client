const net = require("net");
const fs = require("fs");

const PACKET_SIZE = 17; // Each packet has a fixed size
const TOTAL_PACKETS = 14; // Total number of packets expected
const PACKET_JSON_FILE = "received_packets.json";
const RECONNECT_DELAY = 1000; // Delay between reconnection attempts in milliseconds

let client;
let receivedPackets = {};
let missingPackets = [];
let isReconnecting = false;
let done = false; // Flag to indicate if all packets have been received

function createClient() {
  client = net.createConnection({ port: 3000 }, () => {
    console.log("Connected to server.");
    requestAllPackets();
  });

  client.on("data", handleData);
  client.on("end", handleEnd);
  client.on("error", handleError);
}

function requestAllPackets() {
  const requestBuffer = Buffer.alloc(2);
  requestBuffer.writeUInt8(1, 0); // Call type 1 for streaming all packets
  client.write(requestBuffer);
}

function handleData(chunk) {
  while (chunk.length >= PACKET_SIZE) {
    const packet = chunk.slice(0, PACKET_SIZE);
    const packetSequence = packet.readInt32BE(13); // Read the packet sequence number from the packet
    receivedPackets[packetSequence] = packet; // Store the packet
    chunk = chunk.slice(PACKET_SIZE);
  }

  // Check if all packets have been received
  if (Object.keys(receivedPackets).length === TOTAL_PACKETS) {
    if (!done) {
      done = true; // Mark as done
      console.log("All packets received.");
      savePacketsToFile(receivedPackets);
      client.end(); // Close the connection
    }
  } else {
    // Identify missing packets
    missingPackets = [];
    for (let i = 1; i <= TOTAL_PACKETS; i++) {
      if (!receivedPackets[i]) {
        missingPackets.push(i);
      }
    }

    // Request missing packets if any
    if (missingPackets.length > 0) {
      console.log(
        `Missing packets detected. Requesting: ${missingPackets.join(", ")}`
      );
      requestMissingPackets(missingPackets);
    }
  }
}

function requestMissingPackets(missingPackets) {
  missingPackets.forEach((sequenceNumber) => {
    const requestBuffer = Buffer.alloc(2);
    requestBuffer.writeUInt8(0, 0); // Call type 0 for specific packet request
    requestBuffer.writeUInt8(sequenceNumber, 1);
    if (client.writable) {
      client.write(requestBuffer);
    } else {
      console.log("Connection is not writable. Attempting to reconnect.");
      reconnect();
    }
  });
}

function savePacketsToFile(packets) {
  const packetsArray = Object.keys(packets).map((sequenceNumber) => {
    const packet = packets[sequenceNumber];

    // Parse packet data
    const symbol = packet.slice(0, 4).toString("ascii").trim();
    const buySellIndicator = packet.slice(4, 5).toString("ascii");
    const quantity = packet.readInt32BE(5);
    const price = packet.readInt32BE(9);

    return {
      sequenceNumber: parseInt(sequenceNumber, 10),
      symbol,
      buySellIndicator,
      quantity,
      price,
    };
  });

  fs.writeFile(
    PACKET_JSON_FILE,
    JSON.stringify(packetsArray, null, 2),
    (err) => {
      if (err) {
        console.error(`Error writing to file: ${err.message}`);
      } else {
        console.log(`Packets saved to ${PACKET_JSON_FILE}.`);
      }
    }
  );
}

function handleEnd() {
  console.log("Disconnected from server.");
  if (!done && !isReconnecting) {
    console.log("Attempting to reconnect...");
    reconnect();
  }
}

function handleError(err) {
  console.error(`Connection error: ${err.message}`);
  if (!done && !isReconnecting) {
    console.log("Attempting to reconnect...");
    reconnect();
  }
}

function reconnect() {
  isReconnecting = true;
  setTimeout(() => {
    createClient();
    isReconnecting = false;
  }, RECONNECT_DELAY);
}

// Start the client connection
createClient();

// I-am-autogenerated
// The structure and functions are designed to handle client-server communication according to the provided specifications.
